# HW 3
## Анализ прототипов синхронизации процессов

### Запуск

Добавить в Makefile флаги размеров для каждого отдельного размера рабочего буфера (3 разных варианта) <br/>
``` bash
  Make
```

запустить каждую отдельную программу с утилитой time для проверки программы <br/>
``` bash
  time ./a_sender.out & ./a_receiver.out
```

___FLAGS:___ ```-DS_SIZE```, ```-DM_SIZE```, ```-DL_SIZE```<br/>

### Тесты были проведены со следующими параметрами:

|BUF SIZE | S = small | M = medium | L = large|
|------|--------------|------------|----------|
|INPUT FILE | 4kB          | 100MB      | 2GB    |


|BUF IN BYTES  |512 | 4096 | 65536 | 
|--------------|----|------|-------|


### Графики: 

После получения информации о веременах работы различных прототипов синхронизации, получаем графики для различных случаев:

![Image Large]()
<br/>
![Image Medium]()
<br/>
![Image small]()


### Выводы: 
__Message queue__  самая эффективная для отправки небольших сообщений (~512 bytes). В других случаях,к сожалению, они не очень эффективны<br/>

__FIFO__ Стабильно работает в диапазоне средних размеров данных (~100 MB) со всеми размерами буфера и является самым легким для создания и использования методом.<br/>

Самым эффективным методом мне показался: ___virtual-shared memory___, который позволяет немедленно получить доступ к файлам и памяти в других процессах, но если вы работаете с РЕАЛЬНЫМИ большими файлами, размер которых превышает константы из " ipcs -l", вам придется добавить синхронизацию, и время увеличится, тк будет тратиться на чтение и запись<br/>
It will be cost of reading and writing.<br/>
